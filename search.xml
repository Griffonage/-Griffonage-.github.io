<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL从MVCC到ReadView</title>
    <url>/post/23ffdd3c.html</url>
    <content><![CDATA[<h2 id="从问题出发"><a href="#从问题出发" class="headerlink" title="从问题出发"></a>从问题出发</h2><p>假设有 <strong>student</strong> 表存在，且 <strong>stu_name</strong> 字段的<code>初始值都为 AAAAAA</code></p>
<blockquote>
<p>​	下表中<code>步骤3 、步骤5查询出的值分别是多少？ </code>将答案写在纸上，本文将解答你的疑惑，了解问题本质</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">A连接-事务A</th>
<th align="center">B连接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">start transaction;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">update student set stu_name &#x3D; “CCCCCC” where stu_id &#x3D; 1;</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">select stu_name from student where stu_id &#x3D; 1;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center">update student set stu_name &#x3D; “CCCCCC” where stu_id &#x3D; 2;</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">select stu_name from student where stu_id &#x3D; 2;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">commit;</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="先了解事务隔离级别"><a href="#先了解事务隔离级别" class="headerlink" title="先了解事务隔离级别"></a>先了解事务隔离级别</h2><ul>
<li>Read Uncommitted (读未提交)：事务未提交的数据，对其他事务可见<ul>
<li>问题：<code>脏读</code>-A事务读到了B事务修改的未提交的数据</li>
</ul>
</li>
<li>Read Committed (读已提交)：事务只能看见已经提交的数据<ul>
<li>问题：<code>不可重复读</code>-A事务每次查询，都得到最新的已经提交的数据，造成两次查询的结果不一致</li>
</ul>
</li>
<li>Repeatable Read (可重复读)：事务中读取同一行的数据，得到的数据是一致的<ul>
<li>问题：<code>幻读</code>-A事务如果是范围查询后，B事务又在该范围内插入数据，A事务将会查询到B事务插入的数据</li>
</ul>
</li>
<li>Serializable (可串行化)：强制事务串行化执行，将读取到的每一行加锁，占用资源较大<ul>
<li>问题：<code>慢</code></li>
</ul>
</li>
</ul>
<p>注：事务间的隔离性本质上是通过读写锁来实现，不在本文讨论范围内，可以阅读附录推荐了解</p>
<blockquote>
<p> InnoDB默认事务隔离级别是<code>REPEATABLE READ (可重复读)</code>,而这种事务的隔离级别会导致<code>幻读</code>， InnoDB采用了<code>MVCC</code>(多版本并发控制)来解决了这个问题。</p>
</blockquote>
<h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h2><p><code>Multi-Version Concurrency Control</code></p>
<h3 id="表的隐藏字段"><a href="#表的隐藏字段" class="headerlink" title="表的隐藏字段"></a>表的隐藏字段</h3><p><strong>InnoDB</strong>引擎会为数据库中的每一行添加如下隐藏的列</p>
<ul>
<li><code>DB_TRX_ID</code>：行最新更新时，全局事务ID的值，单调递增</li>
<li><code>DB_ROLL_PTR</code>：回滚指针，undo log回滚时，用来找寻回滚版本的指针</li>
<li><code>DB_ROW_ID</code>：行唯一ID，在表有主键时不出现在任何索引中</li>
</ul>
<h3 id="binlog、redolog与undolog"><a href="#binlog、redolog与undolog" class="headerlink" title="binlog、redolog与undolog"></a>binlog、redolog与undolog</h3><p><strong><code>binlog</code><strong>：记录MySQL的数据变动语句，MySQL服务层实现，</strong>根据设置参数刷新进磁盘中</strong>，以二进制文件存储，一般用于<code>主从复制</code>、<code>数据恢复</code></p>
<p><strong><code>redolog</code><strong>：</strong>Innodb特有</strong>，提高性能</p>
<ul>
<li><p>redo log buffer：内存容量，事务提交可以直接存放在内存中，<strong>根据设置参数刷新进磁盘中</strong></p>
</li>
<li><p>redo log file：磁盘上的日志文件，MySQL异常重启后，根据此文件将未提交的事务数据进行重做</p>
</li>
</ul>
<p>注：不论是binlog或redolog都有日志丢失的风险，生产注意将sync_binlog、innodb_flush_log_at_trx_commit两个参数的设置，都设置为1可以分别防止日志丢失</p>
<p><strong><code>undolog</code><strong>：</strong>Innodb实现MVCC的方式</strong>，控制数据的可见性</p>
<p>来看看更新语句的undolog记录，假设stu_id&#x3D;1时，stu_name的 初始值为aaaaaa</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">语句</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务</td>
<td align="center">start transaction;</td>
</tr>
<tr>
<td align="center">第一步</td>
<td align="center">update student set stu_name &#x3D; “bbbbbb” where stu_id &#x3D; 1;</td>
</tr>
<tr>
<td align="center">第二步</td>
<td align="center">update student set stu_name &#x3D; “cccccc” where stu_id &#x3D; 1;</td>
</tr>
<tr>
<td align="center">第三步</td>
<td align="center">update student set stu_name &#x3D; “dddddd” where stu_id &#x3D; 1;</td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center">commit;</td>
</tr>
</tbody></table>
<p>undo log 如下图所示：</p>
<p><img src="https://file.ajungle.cn/img/20220718215350.png"></p>
<p>可以看到，每一个<code>DB_ROLL_PTR</code>的值，都是上一个行版本<code>DB_TRX_ID</code>的值,只要通过最新的一行，就能通过这两个参数找到本次事务所有的数据变动，构成了数值变动的版本链，这个版本链的作用就是:</p>
<blockquote>
<p>控制版本链的哪个版本针对哪个事务是可见的</p>
</blockquote>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>当前事务的<code>ReadView</code>和 undo log 的版本链里面的<code>DB_TRX_ID</code>进行一定规则的比对，从版本链中最新的版本开始比对，直到找到可见的版本为止</p>
<h4 id="如何比对"><a href="#如何比对" class="headerlink" title="如何比对"></a>如何比对</h4><p>ReadView就是一个Class类，有如下字段：</p>
<p><strong>m_ids</strong>：ReadView创建时，活跃读写事务ID列表</p>
<p><strong>m_low_limit_id</strong>：ReadView创建时，活跃事务里面，最小的事务ID</p>
<p><strong>m_up_limit_id</strong>：ReadView创建时，活跃事务里面，最大的事务ID + 1</p>
<p><strong>m_creator_trx_id</strong>：ReadView创建者自身事务ID，仅开启事务是没有事务id的，默认为0，第一条语句执行后才会被赋予真正的值</p>
<h4 id="比对说明"><a href="#比对说明" class="headerlink" title="比对说明"></a>比对说明</h4><ul>
<li><p><code>DB_TRX_ID = creator_trx_id</code>：可见（当前事务可以看见自己修改的数据）</p>
</li>
<li><p><code>DB_TRX_ID &lt; m_low_limit_id</code> 时 : 可见（生成ReadView时，该事务已经提交）</p>
</li>
<li><p><code>DB_TRX_ID &gt;= m_up_limit_id</code> 时 :不可见（生成ReadView时，该事务还未创建）</p>
</li>
<li><p><code>m_low_limit_id &lt;= DB_TRX_ID &lt; m_up_limit_id</code>时</p>
</li>
<li><p>DB_TRX_ID 在 m_ids 列表里面 ：不可见（生成ReadView时，活跃事务还未提交）</p>
</li>
<li><p>DB_TRX_ID 不在 m_ids 列表里面 ：可见（生成ReadView时，事务已经提交）</p>
</li>
</ul>
<h4 id="什么时候生成ReadView"><a href="#什么时候生成ReadView" class="headerlink" title="什么时候生成ReadView"></a>什么时候生成ReadView</h4><p>什么时候生成和MySQL的事务隔离级别有关</p>
<ul>
<li>Read Committed (读已提交)：开启事务后，每次读请求都会创建一份新的ReadView将旧的替换</li>
<li>Repeatable Read (可重复读)：开启事务后，仅第一次读请求创建一次，直到事务结束</li>
</ul>
<h2 id="回到问题本身"><a href="#回到问题本身" class="headerlink" title="回到问题本身"></a>回到问题本身</h2><p>答案是：因为MySQL有不同的隔离级别，造成ReadView生成规则不一致，造成有有两种不同的结果</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">A连接-事务A</th>
<th align="center">B连接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">start transaction;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">update student set stu_name &#x3D; “CCCCCC” where stu_id &#x3D; 1;</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">select stu_name from student where stu_id &#x3D; 1;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center">update student set stu_name &#x3D; “CCCCCC” where stu_id &#x3D; 2;</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">select stu_name from student where stu_id &#x3D; 2;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">commit;</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>REPEATABLE-READ (可重复读)</p>
<ul>
<li>序号3值：CCCCCC</li>
<li>序号5值：AAAAAA</li>
</ul>
<p>READ-COMMITTED(读已提交)</p>
<ul>
<li>序号3值：CCCCCC</li>
<li>序号5值：CCCCCC</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>MVCC在Read Uncommitted (读未提交)和Serializable (可串行化)下不工作，因为前者总是读取最新的数据行，后者会对所有读取的数据行加锁，也就不存在并发问题</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><p><a href="https://icyfenix.cn/architect-perspective/general-architecture/transaction/local.html">《凤凰架构》</a></p>
</li>
<li><p>《高性能MySQL》</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html">MySQL官方网站</a></p>
</li>
<li><p><a href="https://github.com/mysql/mysql-server/blob/5.7/storage/innobase/include/read0types.h">MySQL源码</a></p>
</li>
<li><p><a href="https://blog.jcole.us/innodb/">Jeremy Cole Blog</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/400965090">知乎文章1</a></p>
</li>
<li><p>查询MySQL事务隔离级别语句：<code>show variables like &#39;transaction_isolation&#39;;</code></p>
</li>
<li><p>改变数据库隔离级别：<code>SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>中秋放个我喜欢的歌曲</title>
    <url>/post/ff094b6e.html</url>
    <content><![CDATA[<video src="https://file.ajungle.cn/video/CanonRock.mp4" preload="metadata" controlslist="nodownload" controls playsinline poster=""></video>
]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>杂谈</title>
    <url>/post/bf4ee09f.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在很多时候，自己都有一种强烈的冲动，一种将当时心境记录下来的冲动，然而每到动手之际，却是难以憋出多少文字。</p>
<p>鉴于此情况，单独开一篇文章，用以记录平时生活感悟。</p>
<p>记录自己的琐屑，记录自己的平凡。</p>
<h2 id="2022-10-06"><a href="#2022-10-06" class="headerlink" title="2022-10-06"></a>2022-10-06</h2><p>今天是国庆假期的倒数第二天。</p>
<ol>
<li>国庆第一天：睡觉、打王者、做核酸、骑单车到动物园</li>
<li>国庆第二天：去了<code>碳酸自习室</code>，地方倒是挺大，分为上下两层，人较少（PS：做了啥？？？<strong>翻译、学习设计原则</strong>）</li>
<li>国庆第三天：去了<code>碳酸自习室</code>，冲了几天会员（PS：做了啥？？？<strong>翻译、学习设计原则</strong>）</li>
<li>国庆第四天：睡觉、打王者</li>
<li>国庆第五天：因为核酸到期（需要72小时内阴性）不能做地铁，所以在家附近找了家<code>知了布知自习室</code>，本来以为自己不会喜欢这种小自习室，没想到旁边有个好看的小姐姐，呃呃呃呃呃。。。还不错，再冲个几天会员-.-（PS：做了啥？？？<strong>配置Rust开发环境、学习Rust变量绑定与结构、基本类型</strong>）</li>
<li>国庆第五天：继续去<code>知了布知自习室</code>，下午垃圾桶满了，有强烈的酸味，看到里面的人都能忍，我也就忍了-.-（PS：做了啥？？？<strong>做Rust练习题、学习Rust的所有权和借用、复合类型、流程控制、模式匹配、方法Method</strong>）</li>
</ol>
<p>明天也去自习室吧，想转<strong>区块链工程师</strong>，不知道将来有没有机会</p>
<p>设计原则里面有一个<code>Curly&#39;s Law</code>，是从电影里面得来的，虽然没看过，但是感觉还是很有意境，以下是对话</p>
<blockquote>
<p>Curly: Do you know what the secret of life is?</p>
<p>Curly: This.  [holds up one finger]</p>
<p>Mitch: Your finger?</p>
<p>Curly: One thing. Just one thing. You stick to that and the rest don’t mean shit.</p>
<p>Mitch: But what is the “one thing?”</p>
<p>Curly: [smiles] That’s what <em>you</em> have to find out.</p>
</blockquote>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次成都学车经历</title>
    <url>/post/ca641055.html</url>
    <content><![CDATA[<h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><p>开始时间:<code>2020年10月15日</code></p>
<p>结束时间:<code>2020年12月14日</code></p>
<p>总用时:<code>两个月</code></p>
<h1 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h1><p>报名费:<code>2240</code></p>
<p>科目一</p>
<ul>
<li>考试时间:<code>10月20日</code></li>
<li>考试费用:<code>100</code>元</li>
<li>备考时间:<code>1</code>天</li>
</ul>
<p>科目二</p>
<ul>
<li>考试时间:<code>12月04日</code></li>
<li>考试费用:<code>260</code>元+<code>360</code>元(考试模拟费)</li>
<li>备考时间:<ul>
<li>每次练习<code>1</code>个小时</li>
<li>具体时间如下:<code>10-31 16:00</code>、<code>11-03 10:00</code>、<code>11-05 11:00</code>、<code>11-07 13:00</code>、<code>11-10 18:00</code>、<code>11-12 15:00</code>、<code>11-14 15:00</code>、<code>11-17 11:00</code>、<code>11-19 16:00</code>、<code>11-24 10:00</code>、<code>11-28 10:00</code>、<code>11-30 9:00</code>、<code>11-03 10:00</code>、<code>12-01 12:00</code></li>
<li>总次数:<code>14</code>次</li>
</ul>
</li>
</ul>
<p>科目三</p>
<ul>
<li>考试时间:<code>12月14日</code></li>
<li>考试费用:<code>200</code>元+<code>360</code>元(考试模拟费)+<code>10</code>元(驾驶证工本费)</li>
<li>备考时间:<ul>
<li>每次练习<code>1</code>个小时</li>
<li>具体时间如下:<code>12-07 16:00</code>、<code>12-09 18:40</code>、<code>12-11 11:00</code>、<code>12-12 19:00</code></li>
<li>总次数:<code>4</code>次</li>
</ul>
</li>
</ul>
<blockquote>
<p>科目三分为路考和文考,科目三的文考就是类似科目一的上机考试,知识题目较少且多为多选题</p>
</blockquote>
<p>总费用:</p>
<p>2240   +   100   +   260   +   360   +   200   +   360   +   10 &#x3D; <code>3530</code>元</p>
<h1 id="通关秘诀"><a href="#通关秘诀" class="headerlink" title="通关秘诀"></a>通关秘诀</h1><p><em>方法仅供参考</em></p>
<h2 id="科目一"><a href="#科目一" class="headerlink" title="科目一"></a>科目一</h2><p>科目一考前一天开始刷题,一度十分焦虑</p>
<blockquote>
<p>直到下午1点25分,刚做了300多道题目,还错了177道题,错的比对的都多</p>
</blockquote>
<p>在19日这一天,也就是考前这一天,我彻夜难眠,因为我别说做模拟试卷了,连题目都还没有刷完,后面我改变策略.</p>
<p>按照以下步骤:</p>
<ul>
<li><p>做精题</p>
<ul>
<li>这里我是通过下载了<code>驾考宝典</code>APP(垃圾广告多,但是挺好用),里面的题目虽然很多,但是不适用于我这个临时突击的,发现里面有个”精选500道”这样的栏目,于是我选择先给这个先突突了.</li>
</ul>
</li>
<li><p>做总结归纳</p>
<ul>
<li>在刷题时,我会对做错的题目,去看分析和网友的总结回答,将自己认为重要的记录在纸上(后面科三文考也用上了)</li>
</ul>
</li>
<li><p>刷错题(不多说)</p>
</li>
<li><p>多余时间刷本地区特有题目</p>
<ul>
<li>当然是尽量多刷题,给分类类别题目少的先刷了</li>
</ul>
</li>
</ul>
<p>最后,我那天凌晨三点睡,总共刷了900多道题目,做了两次模拟考试,一次95,一次80多,仓皇上阵</p>
<p>结果:考试<code>98</code>分</p>
<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><p>科目二我的考场是<code>新都正益</code>,驾校早上开车送过去的,没有送回来</p>
<p>考试的顺序是:<code>坡道定点停车</code>&gt;<code>直角转弯</code>&gt;<code>侧方位停车</code>&gt;<code>倒车入库</code>&gt;<code>S弯</code>(大概吧,记忆模糊了<del>看卫星地图</del>)</p>
<p><strong>科目二应该是练习时间花费最长的。</strong></p>
<p>科目二在考试时,第一次先是坡道定点停车扣分,未打转向灯扣分,停车压实线GG.第二次满分通过,有惊无险</p>
<h2 id="科目三"><a href="#科目三" class="headerlink" title="科目三"></a>科目三</h2><h3 id="路考"><a href="#路考" class="headerlink" title="路考"></a>路考</h3><p>练习时间最少,就练习了3到4次,很多东西都是模拟考时那个教练交给我的,模拟教练叫我们尽量记住线路,路程那么远,谁能记住？</p>
<p>考试时,同车4个考生,我排第三个,前两个都没有通过,我运气好一次通过了</p>
<h3 id="文考"><a href="#文考" class="headerlink" title="文考"></a>文考</h3><p>貌似只刷了400多道题,上机考试前还比较慌,一看题目,都是些常识题,so easy</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>必做”精简题”,再做一般题(狂刷完事)</li>
<li>心态要稳,不要被第一次失误,而影响到第二次考试</li>
<li>必须要参加”模拟考试”,虽然要多加钱</li>
</ul>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8之List转Map实现解析</title>
    <url>/post/9a372c09.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>今天同事问到这个问题，之前只会实现，没有仔细分析过原理，现在分析分析</p>
</blockquote>
<h2 id="方式1（基本不用）"><a href="#方式1（基本不用）" class="headerlink" title="方式1（基本不用）"></a>方式1（基本不用）</h2><p>众所周知，在JDK8之后，List转Map的一般实现方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>);</span><br><span class="line">list.add(student1);</span><br><span class="line">list.add(student2);</span><br><span class="line">list.add(student3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">    .collect(Collectors.toMap(Student::getName, Student::getAge));</span><br></pre></td></tr></table></figure>

<h3 id="方式一存在的问题"><a href="#方式一存在的问题" class="headerlink" title="方式一存在的问题"></a>方式一存在的问题</h3><p><code>Collectors.toMap()</code>调用的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(</span><br><span class="line">    								Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                                    Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(HashMap::<span class="keyword">new</span>,</span><br><span class="line">                               uniqKeysMapAccumulator(keyMapper, valueMapper),</span><br><span class="line">                               uniqKeysMapMerger(),</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用<code>CollectorImpl</code>的构造函数前，使用<code>uniqKeysMapAccumulator(keyMapper, valueMapper)</code>对数据进行了处理,处理代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T, K, V&gt;</span><br><span class="line">BiConsumer&lt;Map&lt;K, V&gt;, T&gt; <span class="title function_">uniqKeysMapAccumulator</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends K&gt; keyMapper,</span></span><br><span class="line"><span class="params">                                                Function&lt;? <span class="built_in">super</span> T, ? extends V&gt; valueMapper)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (map, element) -&gt; &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> keyMapper.apply(element);</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> Objects.requireNonNull(valueMapper.apply(element));</span><br><span class="line">        <span class="type">V</span> <span class="variable">u</span> <span class="operator">=</span> map.putIfAbsent(k, v);</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="literal">null</span>) <span class="keyword">throw</span> duplicateKeyException(k, u, v);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Objects.requireNonNull</code>：对值进行了判断，如果为null则抛出<code>NullPointerException</code></li>
<li>通过<code>map.putIfAbsent(k, v);</code>及下面的判断，如果key已经存在，则抛出<code>duplicateKeyException</code></li>
</ul>
<h2 id="方式2（有缺陷）"><a href="#方式2（有缺陷）" class="headerlink" title="方式2（有缺陷）"></a>方式2（有缺陷）</h2><p><code>Collectors.toMap()</code>还有一个重载的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(</span><br><span class="line">    								Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                                    Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper,</span><br><span class="line">                                    BinaryOperator&lt;U&gt; mergeFunction) &#123;</span><br><span class="line">    <span class="keyword">return</span> toMap(keyMapper, valueMapper, mergeFunction, HashMap::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到return这里调用了类中另外一个同名不同参的<code>toMap</code>方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, U&gt;&gt; Collector&lt;T, ?, M&gt; toMap(</span><br><span class="line">    						 Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                             Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper,</span><br><span class="line">                             BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">                             Supplier&lt;M&gt; mapFactory) &#123;</span><br><span class="line">    BiConsumer&lt;M, T&gt; accumulator</span><br><span class="line">        = (map, element) -&gt; map.merge(keyMapper.apply(element),</span><br><span class="line">                                      valueMapper.apply(element), mergeFunction);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(mapFactory, accumulator, mapMerger(mergeFunction), CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，可以通过定义自己的<code>mergeFunction</code>也就是<code>对应map.merge的第三个remappingFunction参数</code>的来控制如何累加，优化后如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>);</span><br><span class="line">list.add(student1);</span><br><span class="line">list.add(student2);</span><br><span class="line">list.add(student3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">    .collect(Collectors.toMap(Student::getName, Student::getAge,(v1, v2)-&gt;v2));</span><br></pre></td></tr></table></figure>

<p>这里，传入了lambda表达式<code>(v1, v2)-&gt;v2)</code>，当key出现重复时，移除原key对应的键值对，放入新key的键值对，<code>map.merge</code>具体代码实现如下：</p>
<h3 id="方式2存在的问题"><a href="#方式2存在的问题" class="headerlink" title="方式2存在的问题"></a>方式2存在的问题</h3><p>在自定义key重复处处理逻辑后，在调用Map的merge方法时，实际上调用了<code>HashMap</code>的merge方法,在其第一行就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span> || remappingFunction == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br></pre></td></tr></table></figure>

<p>当value为null时，抛出<code>NullPointerException</code>异常</p>
<h3 id="方式2问题一般的处理方式"><a href="#方式2问题一般的处理方式" class="headerlink" title="方式2问题一般的处理方式"></a>方式2问题一般的处理方式</h3><p>对null情况进行提前判断，并赋给默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">.collect(Collectors.toMap(</span><br><span class="line">	Student::getName, student -&gt; Optional.ofNullable(student.getAge()).orElse(<span class="number">1</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<h2 id="方式3（建议使用）"><a href="#方式3（建议使用）" class="headerlink" title="方式3（建议使用）"></a>方式3（建议使用）</h2><p>.collect()方法可以自定义自己的<code>累加器容器</code>、<code>累加器容器元素添加方式</code>、<code>累加器容器合并</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">        .collect(HashMap::<span class="keyword">new</span>,(m,v)-&gt;m.put(v.getName(),v.getAge()),HashMap::putAll);</span><br></pre></td></tr></table></figure>

<h2 id="速度测试"><a href="#速度测试" class="headerlink" title="速度测试"></a>速度测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5000000</span> ;i++)&#123;</span><br><span class="line">    Student student= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;测试&quot;</span>+i,i );</span><br><span class="line">    list.add(student);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3-时间测试</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">now1</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">    .collect(HashMap::<span class="keyword">new</span>,(m,v)-&gt;m.put(v.getName(),v.getAge()),HashMap::putAll);</span><br><span class="line"><span class="type">Instant</span> <span class="variable">now2</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(<span class="string">&quot;方式3-时间测试：&quot;</span>+Duration.between(now1,now2).toMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2-时间测试</span></span><br><span class="line">Map&lt;String, Integer&gt; map2 = list.stream()</span><br><span class="line">    .collect(Collectors.toMap(</span><br><span class="line">        Student::getName, student -&gt; Optional.ofNullable(student.getAge()).orElse(<span class="number">1</span>)</span><br><span class="line">    ));</span><br><span class="line"><span class="type">Instant</span> <span class="variable">now3</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(<span class="string">&quot;方式2-时间测试：&quot;</span>+Duration.between(now2,now3).toMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接使用forEach</span></span><br><span class="line">Map&lt;String, Integer&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line"><span class="keyword">for</span>(Student student:list)&#123;</span><br><span class="line">    map3.put(student.getName(),student.getAge());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Instant</span> <span class="variable">now4</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(<span class="string">&quot;时间间隔3：&quot;</span>+Duration.between(now3,now4).toMillis());</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方式<span class="number">3</span>-时间测试：<span class="number">738</span></span><br><span class="line">方式<span class="number">2</span>-时间测试：<span class="number">591</span></span><br><span class="line">时间间隔<span class="number">3</span>：<span class="number">338</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	可以看到，方式3虽然能够避免了空指针及键重复问题，但是创建map和putall的行为仍然会消耗额外时间，但是和方式2消耗时间差距不大，所以对性能要求不高时采用是没有什么问题的。</p>
<p>​    直接使用forEach是时间最快的，但是需要自己维护实现细节，对性能要求高大批量数据时可以使用</p>
</blockquote>
<h2 id="额外记录"><a href="#额外记录" class="headerlink" title="额外记录"></a>额外记录</h2><p><code>.collect</code>：流的终端操作，接收一个<code>Collector&lt;? super T, A, R&gt; collector</code>参数，主要的作用是将流中元素汇聚成一个结果。</p>
<p>最终调用了<code>CollectorImpl</code>类的4参数构造函数，进行了返回，所以对<code>CollectorImpl</code>类进行分析，<code>CollectorImpl</code>实现了<code>Collector</code>接口，接口未如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collector</span>&lt;T, A, R&gt; &#123;</span><br><span class="line">    Supplier&lt;A&gt; <span class="title function_">supplier</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    BiConsumer&lt;A, T&gt; <span class="title function_">accumulator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    BinaryOperator&lt;A&gt; <span class="title function_">combiner</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Function&lt;A, R&gt; <span class="title function_">finisher</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;Characteristics&gt; <span class="title function_">characteristics</span><span class="params">()</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><code>supplier()</code>：返回一个新的累加器容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>accumulator()</code>：将元素添加进累加器容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiConsumer</span>&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t, U u)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>combiner()</code>：合并两个累加器容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BinaryOperator</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BiFunction</span>&lt;T,T,T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiFunction</span>&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t, U u)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>finisher()</code>：结束前对累加器容器进行转换，转换成最终结果容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>characteristics()</code>：定义<code>combiner()</code>函数的行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Characteristics</span> &#123;</span><br><span class="line">	<span class="comment">//表明默认多线程（得到并行流情况下）可以并行调用accumulator()且最终结果正确，不需要调用combiner()，因为操作的是同一个结果容器</span></span><br><span class="line">    CONCURRENT,</span><br><span class="line">	<span class="comment">//不保证结果的顺序性</span></span><br><span class="line">    UNORDERED,</span><br><span class="line">	<span class="comment">//表明 累加器容器 等于 最终结果容器，所以就不会调用finisher()进行最终转换</span></span><br><span class="line">    IDENTITY_FINISH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JDK8</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则</title>
    <url>/post/a151c9f2.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计原则只是供开发人员参考的，并不是一定要遵守的规则，但需要了解并尽可能的去满足设计原则。</p>
<h2 id="KISS"><a href="#KISS" class="headerlink" title="KISS"></a>KISS</h2><blockquote>
<p>Keep It Simple Stupid（保持简单直白）</p>
</blockquote>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>更少的代码节省更多的时间，减少更多的Bug，以及更容易修改</li>
<li>简单是复杂的更高水平</li>
<li>完美并不是没有东西可以被添加进来，而是没有东西可以被带走</li>
</ul>
<h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>不要使用大部分人难以理解的代码，让其晦涩难懂</li>
<li>不要过度优化，不是封装的越多越深越好，也不是底层函数或者高级语法用的越多越好</li>
</ul>
<h2 id="YAGNI"><a href="#YAGNI" class="headerlink" title="YAGNI"></a>YAGNI</h2><blockquote>
<p>you aren’t gonna need it（你不会需要它-不要实现非必要的东西）</p>
</blockquote>
<h3 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>你的时间非常宝贵，任何为将来可能需要的功能做的工作，不但会导致你从当前必须实现的功能分心，而且还浪费了阅读者的时间</li>
<li>这将导致代码臃肿、软件变得庞大且复杂</li>
</ul>
<h3 id="怎么做-1"><a href="#怎么做-1" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>在日常开发中，需要尽可能评估好设计的复杂度，不要过度设计。发现自己设计有不足的地方，，要有<code>持续重构</code>的精神，不断完善自己的设计，不要等到事情累计到不得不重构的时候，那时可能影响范围已经很大，事情往往已经到了积重难返的阶段</li>
</ul>
<h3 id="KISS和YAGNI的异同"><a href="#KISS和YAGNI的异同" class="headerlink" title="KISS和YAGNI的异同"></a>KISS和YAGNI的异同</h3><p>KISS和YAGNI都是在阐述<code>简单</code>这个事情，只是看待的角度不同，KISS是从<code>如何做</code>(保持简单)的角度，YAGNI是从<code>要不要做</code>(不要过度设计)的角度</p>
<h2 id="DTSTTCPW"><a href="#DTSTTCPW" class="headerlink" title="DTSTTCPW"></a>DTSTTCPW</h2><blockquote>
<p>Do The Simplest Thing That Could Possibly Work（做最简单的事情，如果它可能工作）</p>
</blockquote>
<h3 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>如果我们致力于解决真正的问题，就能最大限度地解决真正的问题</li>
<li>专业程序员就是能写出白痴程序员都能读懂的代码，白痴程序员就是写出即使专业程序员都无法读懂的代码</li>
</ul>
<h3 id="怎么做-2"><a href="#怎么做-2" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>询问自己：完成这件事最简单的方式是什么</li>
</ul>
<h2 id="Separation-of-Concerns"><a href="#Separation-of-Concerns" class="headerlink" title="Separation of Concerns"></a>Separation of Concerns</h2><blockquote>
<p>关注点分离是将计算机程序分离成不同部分的设计原则，这样每个部分都单独处理自己的关注点。例如，业务逻辑与非业务逻辑是不同的关注点，更改业务逻辑不应该影响到非业务逻辑</p>
</blockquote>
<h3 id="为什么-3"><a href="#为什么-3" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>简化软件的开发和维护</li>
<li>当每个关注点分离足够好时，代码的可复用性更高且开发及迭代更加具备独立性</li>
</ul>
<h3 id="怎么做-3"><a href="#怎么做-3" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>将程序尽可能分离成各自独立的单一模块中</li>
</ul>
<h2 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h2><blockquote>
<p>Dont’t Repeat Yourself（不要写重复的代码）</p>
<p>系统中的每一个部分都应该单一、清晰、且具备权威性。项目中每一个重要的功能应该仅在一份源代码中，如果相似的功能出现在两个不同的地方，通过抽象出不同部分将其结合起来往往是有益的</p>
</blockquote>
<h3 id="为什么-4"><a href="#为什么-4" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>重复可能导致维护困难、因果颠倒、逻辑互斥</li>
<li>修改系统中任何一个单一的部分，不会改变到其他没有关联的地方</li>
<li>逻辑上相关联的部分修改时，可以保持可预测及同步性</li>
</ul>
<h3 id="怎么做-4"><a href="#怎么做-4" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>将业务规则、长的表达式、if语句、数学公式、元数据等等，放在一个地方</li>
<li>在代码中使用单一、明确的来源</li>
<li>当相似功能的代码出现在不同位置3次时，就应该重构这段代码（为什么不是两次，因为过早的重构可能会导致错误的抽象，而3次时，维护的成本已经超过了重构的成本，以及可能潜在的糟糕设计）</li>
</ul>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>我最怕那些copy别人一大段代码的！！！简直噩梦！！！关键我还碰到了！！！苍天呐！！！</p>
<h2 id="Code-For-The-Maintainer"><a href="#Code-For-The-Maintainer" class="headerlink" title="Code For The Maintainer"></a>Code For The Maintainer</h2><blockquote>
<p>为维护者而编写</p>
</blockquote>
<h3 id="为什么-5"><a href="#为什么-5" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>目前为止，维护是任何一个项目最昂贵的阶段</li>
</ul>
<h3 id="怎么做-5"><a href="#怎么做-5" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>做一个维护者</li>
<li>编写代码时，要将维护你代码的人，当成知道你居住地址且有暴力倾向的精神病患者</li>
<li>编写代码和注释时，要关照级别较低的人，让他们也能够愉快的阅读并能从中学习</li>
<li>不要让他人思考</li>
<li>遵循最小惊讶原则（设计应该按照大多人期望的形式运行，而不是让其感到惊讶或者诧异）</li>
</ul>
<h2 id="Avoid-Premature-Optimization"><a href="#Avoid-Premature-Optimization" class="headerlink" title="Avoid Premature Optimization"></a>Avoid Premature Optimization</h2><blockquote>
<p>避免过早优化（理解过早和非过早至关重要）</p>
</blockquote>
<h3 id="为什么-6"><a href="#为什么-6" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>目前还不清楚瓶颈在哪里</li>
<li>优化后，可能变得更加难以阅读及维护</li>
</ul>
<h3 id="怎么做-6"><a href="#怎么做-6" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>让它更加正确、更加快速</li>
<li>不要在不需要时优化，而是在分析及发现瓶颈后再优化</li>
</ul>
<h2 id="Minimise-Coupling"><a href="#Minimise-Coupling" class="headerlink" title="Minimise Coupling"></a>Minimise Coupling</h2><blockquote>
<p>最小化耦合（耦合是模块&#x2F;组件间项目依赖的程度）</p>
</blockquote>
<h3 id="为什么-7"><a href="#为什么-7" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li><p>一个模块的改变经常会对其他模块造成影响</p>
</li>
<li><p>由于模块间的相互依赖，使用及组装可能花费更多的时间</p>
</li>
<li><p>模块间相互依赖程度高容易导致复用性及可测试降低</p>
</li>
</ul>
<h3 id="怎么做-7"><a href="#怎么做-7" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>消除或者减少不必要的联系</li>
<li>通过隐藏实现细节来减少耦合</li>
<li>遵循<code>迪米特法则</code></li>
</ul>
<h2 id="Law-of-Demeter"><a href="#Law-of-Demeter" class="headerlink" title="Law of Demeter"></a>Law of Demeter</h2><blockquote>
<p>迪米特法则（不要和陌生人说话。如果两个类无需直接通信，那么就不应该发生直接的相互调用，而应该通过第三方转发调用）</p>
</blockquote>
<h3 id="为什么-8"><a href="#为什么-8" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>直接通常导致增强耦合</li>
<li>直接通常显示了过多的实现细节</li>
</ul>
<h3 id="怎么做-8"><a href="#怎么做-8" class="headerlink" title="怎么做"></a>怎么做</h3><p>一个对象的方法只能通过一下方式调用：</p>
<ul>
<li>对象本身</li>
<li>方法中的一个参数</li>
<li>方法中被创建的对象</li>
<li>对象中的直接属性或字段</li>
</ul>
<h2 id="Composition-Over-Inheritance"><a href="#Composition-Over-Inheritance" class="headerlink" title="Composition Over Inheritance"></a>Composition Over Inheritance</h2><blockquote>
<p>组合优于继承</p>
</blockquote>
<h3 id="为什么-9"><a href="#为什么-9" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>类之间的耦合更低</li>
<li>继承打破封装</li>
</ul>
<h3 id="怎么做-9"><a href="#怎么做-9" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>继承前考虑父类是否有缺陷，而你是否愿意将缺陷传播到你的类中</li>
<li>[has a]或者[use a]的类关系用组合；[is a]的情况，才能使用继承</li>
</ul>
<h2 id="Orthogonality"><a href="#Orthogonality" class="headerlink" title="Orthogonality"></a>Orthogonality</h2><blockquote>
<p>正交性，系统中概念上不相干的事情不应该联系在一起</p>
</blockquote>
<h3 id="为什么-10"><a href="#为什么-10" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>设计越正交，异常越少，使得学习、阅读、编写代码更加容易</li>
</ul>
<h2 id="Robustness-Principle"><a href="#Robustness-Principle" class="headerlink" title="Robustness Principle"></a>Robustness Principle</h2><blockquote>
<p>伯斯塔尔定律，对你想要做的要求严格，对你从其他人那里接收的保持宽松</p>
</blockquote>
<h3 id="为什么-11"><a href="#为什么-11" class="headerlink" title="为什么"></a>为什么</h3><p>为了在服务迭代过程中，提供者能够做出新的需求，同时对现有客户造成最小的影响</p>
<h3 id="怎么做-10"><a href="#怎么做-10" class="headerlink" title="怎么做"></a>怎么做</h3><p>发送给其他机器的代码或者是命令，应该确保完全符合规范。但是接收的输入应该接受不符合规范的，只要含义清楚。</p>
<h2 id="Inversion-of-Control"><a href="#Inversion-of-Control" class="headerlink" title="Inversion of Control"></a>Inversion of Control</h2><blockquote>
<p>控制反转原则，也叫好莱坞原则（不要打电话给我，我们会打电话给你），使可重用的代码和解决具体问题的代码，即使他们在一个应用里</p>
</blockquote>
<h3 id="为什么-12"><a href="#为什么-12" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>控制反转被用来增加程序的模块化以及可扩展性</li>
<li>将任务的执行与实现解耦</li>
<li>将模块专注于他们所涉及的任务</li>
<li>防止模块被替换带来的副作用</li>
</ul>
<h3 id="怎么做-11"><a href="#怎么做-11" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>使用工厂模式</li>
<li>使用服务定位模式</li>
<li>使用依赖注入</li>
<li>使用上下文查找</li>
<li>使用模板方法模式</li>
<li>使用策略模式</li>
</ul>
<h2 id="Maximise-Cohesion？"><a href="#Maximise-Cohesion？" class="headerlink" title="Maximise Cohesion？"></a>Maximise Cohesion？</h2><blockquote>
<p>最大化内聚，</p>
</blockquote>
<h2 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h2><blockquote>
<p>里氏替换原则，程序中的对象可以被其子类替换，而不改变程序的正确性</p>
</blockquote>
<h2 id="Open-x2F-Closed-Principle"><a href="#Open-x2F-Closed-Principle" class="headerlink" title="Open&#x2F;Closed Principle"></a>Open&#x2F;Closed Principle</h2><blockquote>
<p>开闭原则，软件实体应该对扩展开放，对修改关闭</p>
</blockquote>
<h3 id="为什么-13"><a href="#为什么-13" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>通过对现有代码最小化的改动来改善代码的可维护性和稳定性</li>
</ul>
<h3 id="怎么做-12"><a href="#怎么做-12" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li><p>编写可以扩展的类（而不是可以修改的类）</p>
</li>
<li><p>仅暴露可移动可修改的部分，隐藏其他部分</p>
</li>
</ul>
<h2 id="Single-Responsibility-Principle"><a href="#Single-Responsibility-Principle" class="headerlink" title="Single Responsibility Principle"></a>Single Responsibility Principle</h2><blockquote>
<p>单一责任原则，一个类不应该有超过一个需要改变的理由</p>
</blockquote>
<h3 id="为什么-14"><a href="#为什么-14" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>可维护性：改变应该仅在一个模块或者类中进行</li>
</ul>
<h3 id="怎么做-13"><a href="#怎么做-13" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>参考Curly’s Law</li>
</ul>
<h3 id="Hide-Implementation-Details"><a href="#Hide-Implementation-Details" class="headerlink" title="Hide Implementation Details"></a>Hide Implementation Details</h3><blockquote>
<p>隐藏实现细节，一个软件模块通过提供一个接口来隐藏信息，同时不泄露任何不必要的信息</p>
</blockquote>
<h3 id="为什么-15"><a href="#为什么-15" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>当一个实现改变，使用接口的客户端不用进行更改</li>
</ul>
<h3 id="怎么做-14"><a href="#怎么做-14" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>最小化类和变量的可访问性</li>
<li>不要将变量数据设置为public</li>
<li>避免放置私有的实现细节放到类的接口上</li>
<li>减少耦合以隐藏更多的实现细节</li>
</ul>
<h2 id="Curly’s-Law"><a href="#Curly’s-Law" class="headerlink" title="Curly’s Law"></a>Curly’s Law</h2><blockquote>
<p>科里定律，为任何特定代码选择一件单一、明确的目标，做一件事情</p>
</blockquote>
<h2 id="Encapsulate-What-Changes"><a href="#Encapsulate-What-Changes" class="headerlink" title="Encapsulate What Changes"></a>Encapsulate What Changes</h2><blockquote>
<p>封装经常修改的代码</p>
</blockquote>
<h3 id="为什么-16"><a href="#为什么-16" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>当改变发生时，减少需要修改的地方</li>
</ul>
<h3 id="怎么做-15"><a href="#怎么做-15" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>封装API背后不同的概念</li>
<li>尽可能将不同概念分离到它自己的模块</li>
</ul>
<h2 id="Interface-Segregation-Principle"><a href="#Interface-Segregation-Principle" class="headerlink" title="Interface Segregation Principle"></a>Interface Segregation Principle</h2><blockquote>
<p>接口隔离原则。将臃肿的接口减少为多个更小、更具体的客户端特定接口。接口应该更依赖于调用它的代码，而不是实现它的代码。</p>
</blockquote>
<h2 id="Command-Query-Separation"><a href="#Command-Query-Separation" class="headerlink" title="Command Query Separation"></a>Command Query Separation</h2><blockquote>
<p>命令查询分离，每个方法要么是执行操作的命令，要么是向调用者返回数据的查询，但不能两个同时存在。这样就能使得使用者更加方向的调用。</p>
</blockquote>
<h3 id="为什么-17"><a href="#为什么-17" class="headerlink" title="为什么"></a>为什么</h3><ul>
<li>通过清除的将发放划分为查询和命令，程序员可以在不知道方法实现细节的情况下，更加有信心进行编码</li>
</ul>
<h3 id="怎么做-16"><a href="#怎么做-16" class="headerlink" title="怎么做"></a>怎么做</h3><ul>
<li>将一个方法作为查询或命令实现</li>
<li>明确方法的名称，通过约定名称的方式告知是查询还是命令</li>
</ul>
<h2 id="Murphy’s-Law"><a href="#Murphy’s-Law" class="headerlink" title="Murphy’s Law"></a>Murphy’s Law</h2><blockquote>
<p>墨菲定律，任何可能出错的都会出错</p>
</blockquote>
<h2 id="Brooks’s-Law"><a href="#Brooks’s-Law" class="headerlink" title="Brooks’s Law"></a>Brooks’s Law</h2><blockquote>
<p> 布鲁克斯法则，向已经延误的项目添加人力，只会使其更晚</p>
</blockquote>
<h2 id="Linus’s-Law"><a href="#Linus’s-Law" class="headerlink" title="Linus’s Law"></a>Linus’s Law</h2><blockquote>
<p>林纳斯定律，给予足够的眼睛关注，所有的bug都会显现，代码检视很重要</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
      </tags>
  </entry>
</search>
